import { connect } from "cloudflare:sockets";

const UUID = "e258977b-e413-4718-a3af-02d75492c349";

const FALLBACK_HOST = "jp.x9527.xyz";
const FALLBACK_PORT = 443;

const WS_PATH = encodeURIComponent("/?ed=2095");

const ENABLE_ECH = true;

const CSV_URL = "https://ccq-4bs.pages.dev/heads/main/hebing.csv?token=CCQ";

const AT_IPV4 = 1;
const AT_DOMAIN = 2;
const AT_IPV6 = 3;

const te = new TextEncoder();
const td = new TextDecoder();

export default {
  async fetch(request, env) {
    try {
      const url = new URL(request.url);

      if (request.headers.get("Upgrade") === "websocket") {
        return handleWsRequest(request);
      }

      if (request.method === "GET") {
        if (url.pathname === "/") {
          return new Response(
            "<!doctype html><meta charset=utf-8><title>OK</title><h1>可以了</h1><p>www.x-aniu.com</p>",
            { headers: { "content-type": "text/html; charset=utf-8" } }
          );
        }

        if (url.pathname === `/${UUID}`) {
          return handleSubscriptionRequest(request);
        }
      }

      return new Response("Not Found", { status: 404 });
    } catch (e) {
      return new Response(String(e?.message || e), { status: 500 });
    }
  },
};

async function handleSubscriptionRequest(request) {
  const url = new URL(request.url);
  const host = url.hostname;

  const ech = ENABLE_ECH ? await fetchECH() : null;

  const nodes = await fetchCsvNodes(CSV_URL);
  const links = nodes.length
    ? nodes.map((n) => buildVlessLink(UUID, n.ip, n.port, n.name, host, ech))
    : [
        `vless://00000000-0000-0000-0000-000000000000@127.0.0.1:80?encryption=none&security=none&type=ws&host=error.com&path=%2F#${encodeURIComponent(
          "NO-NODES"
        )}`,
      ];

  return new Response(btoa(links.join("\n")), {
    headers: {
      "content-type": "text/plain; charset=utf-8",
      "cache-control": "no-store",
    },
  });
}

function buildVlessLink(uuid, ip, port, name, workerHost, ech) {
  const safeIP = ip.includes(":") ? `[${ip}]` : ip;
  const label = encodeURIComponent(name || `${ip}:${port}`);

  const p = new URLSearchParams({
    encryption: "none",
    security: "tls",
    sni: workerHost,
    fp: ech ? "chrome" : "randomized",
    type: "ws",
    host: workerHost,
    path: WS_PATH,
  });

  if (ech) {
    p.set("alpn", "h3,h2,http/1.1");
    p.set("ech", ech);
  }

  return `vless://${uuid}@${safeIP}:${port}?${p.toString()}#${label}`;
}

async function fetchCsvNodes(csvUrl) {
  try {
    const r = await fetch(csvUrl, { signal: AbortSignal.timeout(8000) });
    if (!r.ok) return [];
    const text = (await r.text()).trim().replace(/\r/g, "");
    if (!text) return [];

    // 格式: ip:port#name
    const out = [];
    for (const line of text.split("\n")) {
      const s = line.trim();
      if (!s) continue;
      const m = s.match(/^([^:]+):(\d+)\s*#\s*(.*)$/);
      if (!m) continue;
      out.push({ ip: m[1], port: Number(m[2]), name: (m[3] || m[1]).trim() });
    }
    return out;
  } catch {
    return [];
  }
}

/** 尽量短：只查 cloudflare-ech.com 的 65 记录，提取 ech=... */
async function fetchECH() {
  const tries = [
    ["https://cloudflare-dns.com/dns-query?name=cloudflare-ech.com&type=65", "application/dns-json"],
    ["https://dns.google/resolve?name=cloudflare-ech.com&type=65", "application/json"],
  ];

  for (const [u, accept] of tries) {
    try {
      const r = await fetch(u, {
        headers: { Accept: accept },
        signal: AbortSignal.timeout(5000),
      });
      if (!r.ok) continue;
      const j = await r.json();
      const ans = j?.Answer || [];
      for (const a of ans) {
        const d = String(a?.data || "");
        const m = d.match(/ech=([^\s"']+)/);
        if (m?.[1]) return m[1];
        // 有些实现会把 data 做 base64，这里兼容一下
        try {
          const decoded = atob(d);
          const m2 = decoded.match(/ech=([^\s"']+)/);
          if (m2?.[1]) return m2[1];
        } catch {}
      }
    } catch {}
  }
  return null;
}

async function handleWsRequest(request) {
  const pair = new WebSocketPair();
  const [client, server] = Object.values(pair);
  server.accept();

  let remote = null;
  let isDns = false;

  const early = request.headers.get("sec-websocket-protocol") || "";
  const readable = makeReadableStream(server, early);

  readable
    .pipeTo(
      new WritableStream({
        async write(chunk) {
          if (isDns) return forwardDns(chunk, server, null);

          if (remote) {
            const w = remote.writable.getWriter();
            await w.write(chunk);
            w.releaseLock();
            return;
          }

          const h = parseHeader(chunk, UUID);
          if (h.err) throw new Error(h.err);

          if (h.isUDP) {
            if (h.port !== 53) throw new Error("UDP only for DNS(53)");
            isDns = true;
            return forwardDns(chunk.slice(h.dataIndex), server, new Uint8Array([h.ver, 0]));
          }

          const respHeader = new Uint8Array([h.ver, 0]);
          const raw = chunk.slice(h.dataIndex);

          await forwardTcp(h.host, h.port, raw, server, respHeader, (sock) => (remote = sock));
        },
      })
    )
    .catch(() => closeQuiet(server));

  return new Response(null, { status: 101, webSocket: client });
}

async function forwardTcp(host, port, firstData, ws, respHeader, setRemote) {
  const connectOnce = async (h, p) => {
    const s = connect({ hostname: h, port: p });
    const w = s.writable.getWriter();
    await w.write(firstData);
    w.releaseLock();
    return s;
  };

  const connectWithFallback = async () => {
    const s = await connectOnce(FALLBACK_HOST || host, FALLBACK_PORT || port);
    setRemote(s);
    s.closed.catch(() => {}).finally(() => closeQuiet(ws));
    pipeRemoteToWs(s, ws, respHeader);
  };

  try {
    const s = await connectOnce(host, port);
    setRemote(s);
    pipeRemoteToWs(s, ws, respHeader, connectWithFallback);
  } catch {
    await connectWithFallback();
  }
}

function pipeRemoteToWs(remote, ws, header, retry) {
  let hasData = false;
  remote.readable
    .pipeTo(
      new WritableStream({
        async write(chunk, controller) {
          hasData = true;
          if (ws.readyState !== 1) return controller.error("ws not open");

          if (header) {
            ws.send(concatU8(header, chunk));
            header = null;
          } else {
            ws.send(chunk);
          }
        },
      })
    )
    .catch(() => closeQuiet(ws))
    .finally(() => {
      if (!hasData && retry) retry();
    });
}

async function forwardDns(udpData, ws, header) {
  try {
    const s = connect({ hostname: "8.8.4.4", port: 53 });
    let h = header;

    const w = s.writable.getWriter();
    await w.write(udpData);
    w.releaseLock();

    await s.readable.pipeTo(
      new WritableStream({
        async write(chunk) {
          if (ws.readyState !== 1) return;
          if (h) {
            ws.send(concatU8(h, chunk));
            h = null;
          } else {
            ws.send(chunk);
          }
        },
      })
    );
  } catch {}
}

function parseHeader(buf, uuid) {
  if (buf.byteLength < 24) return { err: "invalid data" };

  const u8 = new Uint8Array(buf);
  const ver = u8[0];

  // UUID: bytes[1..16]
  if (bytesToUuid(u8, 1) !== uuid) return { err: "invalid user" };

  const optLen = u8[17];
  const cmd = u8[18 + optLen];
  const isUDP = cmd === 2;
  if (cmd !== 1 && cmd !== 2) return { err: "unsupported cmd" };

  const portIndex = 19 + optLen;
  const port = (u8[portIndex] << 8) | u8[portIndex + 1];

  let idx = portIndex + 2;
  const at = u8[idx++];

  let host = "";
  if (at === AT_IPV4) {
    host = `${u8[idx++]}.${u8[idx++]}.${u8[idx++]}.${u8[idx++]}`;
  } else if (at === AT_DOMAIN) {
    const len = u8[idx++];
    host = td.decode(buf.slice(idx, idx + len));
    idx += len;
  } else if (at === AT_IPV6) {
    const dv = new DataView(buf, idx, 16);
    const parts = [];
    for (let i = 0; i < 8; i++) parts.push(dv.getUint16(i * 2).toString(16));
    host = parts.join(":");
    idx += 16;
  } else {
    return { err: "bad addr type" };
  }

  if (!host) return { err: "empty host" };
  return { ver, isUDP, port, host, dataIndex: idx };
}

function makeReadableStream(ws, earlyDataHeader) {
  let cancelled = false;

  return new ReadableStream({
    start(controller) {
      ws.addEventListener("message", (e) => !cancelled && controller.enqueue(e.data));
      ws.addEventListener("close", () => {
        if (cancelled) return;
        closeQuiet(ws);
        controller.close();
      });
      ws.addEventListener("error", (e) => controller.error(e));

      const early = base64ToArrayBuffer(earlyDataHeader);
      if (early) controller.enqueue(early);
    },
    cancel() {
      cancelled = true;
      closeQuiet(ws);
    },
  });
}

function base64ToArrayBuffer(s) {
  if (!s) return null;
  try {
    s = s.replace(/-/g, "+").replace(/_/g, "/");
    const bin = atob(s);
    const u8 = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
    return u8.buffer;
  } catch {
    return null;
  }
}

function concatU8(headerU8, chunk) {
  const b = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : new Uint8Array(chunk);
  const out = new Uint8Array(headerU8.length + b.length);
  out.set(headerU8, 0);
  out.set(b, headerU8.length);
  return out.buffer;
}

function closeQuiet(ws) {
  try {
    if (ws.readyState === 1 || ws.readyState === 2) ws.close();
  } catch {}
}

const HEX = Array.from({ length: 256 }, (_, i) => (i + 256).toString(16).slice(1));
function bytesToUuid(arr, o) {
  return (
    HEX[arr[o]] +
    HEX[arr[o + 1]] +
    HEX[arr[o + 2]] +
    HEX[arr[o + 3]] +
    "-" +
    HEX[arr[o + 4]] +
    HEX[arr[o + 5]] +
    "-" +
    HEX[arr[o + 6]] +
    HEX[arr[o + 7]] +
    "-" +
    HEX[arr[o + 8]] +
    HEX[arr[o + 9]] +
    "-" +
    HEX[arr[o + 10]] +
    HEX[arr[o + 11]] +
    HEX[arr[o + 12]] +
    HEX[arr[o + 13]] +
    HEX[arr[o + 14]] +
    HEX[arr[o + 15]]
  );
}
